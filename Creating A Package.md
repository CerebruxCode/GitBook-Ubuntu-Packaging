# Δημιουργία πακέτου από το μηδέν (αναφορικά)

Χωρίς να μπούμε σε λεπτομέρειες στην παρούσα στιγμή, διότι η διαδικασία της δημιουργίας από το μηδέν ενός πακέτου στο Ubuntu για ένα λογισμικό, είναι περίπλοκη αρχικά, ας εξετάσουμε εν συντομία και εδώ την απλούστερη περίπτωση. Η διαδικασία είναι παρόμοια. Αυτό που αλλάζει, ουσιαστικά, είναι η «χειροκίνητη» δημιουργία του καταλόγου «**debian**», σε αντίθεση με την προηγούμενη περίπτωση όπου πρακτικά το πήραμε από προηγούμενη έκδοση λογισμικού και το εφαρμόσαμε στη νεότερη.


> Και εδώ, θα χρησιμοποιήσουμε ως παράδειγμα το λογισμικό «**fldigi**», το οποίο είναι λογισμικό για ραδιοερασιτέχνες (*HAM Radio*) και δεν υπάρχει στα αποθετήρια του Ubuntu.




## • Βήμα 1: Λήψη λογισμικού



Στην προηγούμενη περίπτωση της αναβάθμισης, κατεβάσαμε τον πηγαίο κώδικα με τον κατάλογο «**debian**» ενσωματωμένο από το *Launchpad*. Εδώ, δεν έχουμε έτοιμο πακέτο για να δουλέψουμε πάνω σε αυτό, οπότε πρέπει να κατεβάσουμε τον πηγαίο κώδικα από την ιστοσελίδα του upstream.

Ανοίγουμε το τερματικό μας, πηγαίνουμε στον φάκελο στον οποίο δουλεύουμε (όπως και στην προηγούμενη περίπτωση) και κατεβάζουμε τον πηγαίο κώδικα:
```bash
wget ΣΥΝΔΕΣΜΟΣ_TARBALL```
Και στη συνέχεια, το αποσυμπιέζουμε:
```bash
tar [options] TARBALL```

Και μετά την αποσυμπίεση θα έχουμε στον φάκελο όπου δουλέυουμε:

* Το tarball «**ΛΟΓΙΣΜΙΚΟ-ΕΚΔΟΣΗ(Upstream).tar**» το οποίο κατεβάσαμε.
* Τον φάκελο «**ΛΟΓΙΣΜΙΚΟ-ΕΚΔΟΣΗ(Upstream)**» τον οποίο αποσυμπιέσαμε από το tarball.

![](https://cerebrux.files.wordpress.com/2016/04/wgeta.png?w=735)
![](https://cerebrux.files.wordpress.com/2016/04/wgetb.png?w=735)


## • Βήμα 2: Μεταγλώττιση πηγαίου κώδικα



Προτού προχωρήσουμε με την δημιουργία του πακέτου, θα πρέπει να εγκαταστήσουμε το λογισμικό στο σύστημά μας προκειμένου να δούμε αν γίνεται σωστά. Ο μόνος τρόπος να γίνει κάτι τέτοιο είναι η **μεταγλώττιση** (*compiling*) του πηγαίου κώδικα. Αυτό γίνεται ως εξής:
```bash
cd ΛΟΓΙΣΜΙΚΟ-ΕΚΔΟΣΗ(Upstream)
./configure
make
sudo make install```


> Εδώ, είναι σημαντικό να καταγράψουμε προσεκτικά τυχόντα λάθη τα οποία αφορούν ελλείψεις πακέτων απαραιτήτων για την σωστή λειτουργία του λογισμικού. Αυτά τα πακέτα θα είναι οι **εξαρτήσεις** του λογισμικού που λείπουν από το σύστημά μας. Οπότε, για το ενδεχόμενο εμφάνισης τέτοιων σφαλμάτων, σταματάμε την διαδικασία και εγκαθιστούμε το πακέτο που λείπει (με τον γνωστό τρόπο με το *apt-get*) και ξεκινάμε εκ νέου την διαδικασία της μεταγλώττισης. Επαναλαμβάνουμε έως ότου δεν υπάρχουν πλέον πακέτα που λείπουν.

![](https://cerebrux.files.wordpress.com/2016/04/configure.png?w=735)
![](https://cerebrux.files.wordpress.com/2016/04/make.png?w=735)
![](https://cerebrux.files.wordpress.com/2016/04/install.png?w=735)


## • Βήμα 3: Έλεγχος λειτουργίας



Αφού, όπως φαίνεται, η εγκατάσταση ολοκληρώθηκε χωρίς σφάλματα, πρέπει να ελέγξουμε αν το λογισμικό λειτουργεί σωστά. Οπότε το τρέχουμε:
```bash
εντολή-εκτέλεσης```

Και αφού διαπιστώσουμε πως λειτουργεί σωστά, είμαστε έτοιμοι να συνεχίσουμε.
![](https://cerebrux.files.wordpress.com/2016/04/run.png?w=735)
![](https://cerebrux.files.wordpress.com/2016/04/fldigi.png?w=800)


## • Βήμα 4: Δημιουργία καταλόγου «debian»



Αυτό που διαφέρει στον πηγαίο κώδικα ενός καταλόγου upstream λογισμικού, από αυτόν ενός λογισμικού για Ubuntu είναι η ύπαρξη του καταλόγου «**debian**». Αυτός ο κατάλογος ουσιαστικά καθορίζει την εγκατάσταση και την λειτουργία του λογισμικού στο Ubuntu. Στην προηγούμενη περίπτωση της αναβάθμισης από παλαιότερο πακέτο, ουσιαστικά πήραμε τον κατάλογο «**debian**» έτοιμο από την παλιά, και τον μεταφέραμε στην νέα έκδοση. Εδώ, αφού ξεκινάμε από το μηδέν, δεν έχουμε κάτι έτοιμο, οπότε πρέπει να δημιουργήσουμε μόνοι μας τον κατάλογο «**debian**».

Αρχικά, όμως, θα πρέπει να μετονομάσουμε το tarball με τον πηγαίο κώδικα, ώστε αυτός να ακολουθεί το μοτίβο των κανονισμών του Debian (και Ubuntu) packaging. Στο τερματικό, αφού μεταβούμε ξανά στον αρχικό μας φάκελο, εκτελούμε:
```bash
cd .. && mv ΛΟΓΙΣΜΙΚΟ-ΕΚΔΟΣΗ(Upstream).tar ΛΟΓΙΣΜΙΚΟ_ΕΚΔΟΣΗ(Upstream).orig.tar```

Η διαφορά είναι πως αντί για παύλα, το όνομα του λογισμικού από την έκδοση χωρίζεται με **underscore**, καθώς και η προσθήκη του «**orig**».

Τώρα μπορούμε να δημιουργήσουμε τον κατάλογο «**debian**», εκτελώντας:
```bash
bzr dh-make ΛΟΓΙΣΜΙΚΟ ΕΚΔΟΣΗ ΛΟΓΙΣΜΙΚΟ_ΕΚΔΟΣΗ(Upstream).orig.tar```

Δηλαδή, ορίζουμε το **όνομα** του λογισμικού, την **έκδοσή** του με είσοδο από το αρχείο **tarball**. Εκτελώντας, λοιπόν, την παραπάνω εντολή, θα κληθούμε να απαντήσουμε για τον τύπο του πακέτου που χρησιμοποιούμε:
```bash
Please respond with one of the following: s,i,l,p
Type of package: (single, indep, library, python)
[s/i/l/p]?```

Επιλέγουμε τον τύπο του πακέτου πατώντας το αντίστοιχο πλήκτρο (στο παράδειγμά μας, είναι «**s**»). Και στη συνέχεια, θα κληθούμε να επιβεβαιώσουμε άλλα στοιχεία:
```bash
Email-Address : ΤΟ E-MAIL ΜΑΣ
License : blank
Package Name : ΟΝΟΜΑ ΠΑΚΕΤΟΥ
Maintainer Name : ΟΝΟΜΑ ΕΠΙΘΕΤΟ
Version : ΑΡΙΘΜΟΣ ΕΚΔΟΣΗΣ
Package Type : ΤΥΠΟΣ
Date : ΗΜΕΡΟΜΗΝΙΑ
Are the details correct? [Y/n/q]```

Τα προσωπικά μας στοιχεία θα έχουν εισαχθεί αυτόματα λόγω των παραμέτρων που προσθέσαμε στο **.bashrc** σε προηγούμενη ενότητα, στην προετοιμασία. Επίσης, το **όνομα** του πακέτου και η **έκδοσή** του έχουν εισαχθεί αυτόματα, το ίδιο και η **ημερομηνία**. Η **άδεια** (σημαντική μη-λεπτομέρεια) δεν έχει μπει αυτόματα. Παρόλα αυτά, εμείς πατάμε το πλήκτρο «**Y**» για να επιβεβαιώσουμε τις πληροφορίες και θα κάνουμε όποιες αλλαγές είναι απαραίτητες αργότερα. Έτσι, ολοκληρώνεται η δημιουργία του καταλόγου «**debian**» στο λογισμικό, σε έναν νέο φάκελο που δημιουργήθηκε:

* Ο φάκελος «**ΟΝΟΜΑ_ΛΟΓΙΣΜΙΚΟΥ**».

![](https://cerebrux.files.wordpress.com/2016/04/dhmake1.png?w=735)
![](https://cerebrux.files.wordpress.com/2016/04/dhmake2.png?w=735)
![](https://cerebrux.files.wordpress.com/2016/04/dhmake3.png?w=735)
![](https://cerebrux.files.wordpress.com/2016/04/dhmake4.png?w=735)


## • Βήμα 5: Ρύθμιση αρχείων του καταλόγου «debian»



Ο κατάλογος «**debian**» δημιουργήθηκε. Όμως, τα αρχεία που περιέχει περιέχουν απλά ένα template που επεξηγεί πως θα είναι η μορφή τους. Πρέπει να τα ρυθμίσουμε σωστά. Αυτό είναι και το βήμα που απαιτεί την μεγαλύτερη προσοχή και μπορεί να γίνει αρκετά περίπλοκο, αναλόγως το λογισμικό και τις ανάγκες του. Τα αρχεία που θα πρέπει να επεξεργαστούμε, προκειμένου να λειτουργήσει σωστά το πακέτο που θα παραχθεί από το λογισμικό, είναι τα εξής:

* debian/changelog
* debian/compat
* debian/control
* debian/copyright
* debian/ΛΟΓΙΣΜΙΚΟ-docs.docs
* debian/rules
* debian/watch
* debian/source/format


Ας συμμαζέψουμε, αρχικά, τον κατάλογο «**debian**»:

* Θα μεταβούμε στον κατάλογο «**debian**», ώστε αρχικά, να συμμαζέψουμε λίγο τον φάκελο:
```bash
cd ΟΝΟΜΑ_ΛΟΓΙΣΜΙΚΟΥ/debian```
* Διαγράφουμε όλα τα αρχεία με κατάληξη «**.ex**» και «**.EX**» και τα αρχεία «**outfile**» και «**README**»:
```bash
rm -r *.ex *.EX outfile README*```
* Από την λίστα των αρχείων παραπάνω, λείπουν τα δύο τελευταία. Τα δημιουργούμε:
```bash
touch watch source/format```
* Μετονομάζουμε το αρχείο «**ΛΟΓΙΣΜΙΚΟ-docs.docs**» σε «**ΛΟΓΙΣΜΙΚΟ.docs**»:
```bash
mv ΛΟΓΙΣΜΙΚΟ-docs.docs ΛΟΓΙΣΜΙΚΟ.docs```

![](https://cerebrux.files.wordpress.com/2016/04/debian1.png?w=680)

Τώρα, ήρθε η στιγμή που θα πρέπει να επεξεργαστούμε κάποια αρχεία.

Το αρχείο «**debian/watch**» πρέπει να περιέχει τον σύνδεσμο του λογισμικού upstream, ώστε να ανιχνεύεται από την εντολή «**uscan**» σε μελλοντική αναβάθμιση του πακέτου. Ο σύνδεσμος πρέπει να έχει τη μορφή:
```bash
http://ΙΣΤΟΤΟΠΟΣ/ΛΟΓΙΣΜΙΚΟ/TARBALL-(.*).tar.```
Τοποθετούμε τον σύνδεσμο κατάλληλα:
```bash
version=3

http://ΙΣΤΟΤΟΠΟΣ/ΛΟΓΙΣΜΙΚΟ/ΛΟΓΙΣΜΙΚΟ-(.*).tar.gz```

> Ο σύνδεσμος πρέπει να γραφτεί προσεκτικά ώστε να λειτουργεί σωστά η εντολή «uscan».


Το αρχείο «**debian/copyright**» πρέπει να περιέχει λεπτομέρειες για την άδεια του λογισμικού. Αυτό το αρχείο θα έχει τη μορφή:
```bash
Name: ΟΝΟΜΑ ΠΑΚΕΤΟΥ
Maintainer: ΟΝΟΜΑ ΕΠΙΘΕΤΟ <E-MAIL>
Source: ΙΣΤΟΤΟΠΟΣ ΚΩΔΙΚΑ

Files: *
Copyright: ΙΔΙΟΚΤΗΤΗΣ
License: ΑΔΕΙΑ

License: ΑΔΕΙΑ
ΠΕΡΙΓΡΑΦΗ ΑΔΕΙΑΣ.```

> Η άδεια μπορεί να βρεθεί στον κατάλογο του λογισμικού (τον πατρικό του «**debian**») στο αρχείο «**COPYING**» (το εκάστοτε λογισμικό μπορεί να έχει άλλο όνομα σχετικό με άδεια).


Το αρχείο «**debian/control**» μας είναι ήδη οικείο από την προηγούμενη περίπτωση. Περιέχει τις πληροφορίες του πακέτου καθώς και την λίστα των εξαρτήσεων:
```bash
Source: ΟΝΟΜΑ ΠΑΚΕΤΟΥ
Section: ΚΑΤΗΓΟΡΙΑ
Priority: ΠΡΟΤΕΡΑΙΟΤΗΤΑ
Maintainer: ΟΝΟΜΑ ΕΠΙΘΕΤΟ <E-MAIL>
XSBC-Original-Maintainer: ΑΡΧΙΚΟΣ ΣΥΓΓΡΑΦΕΑΣ <ΤΟ E-MAIL ΤΟΥ>
Build-Depends: ΛΙΣΤΑ ΕΞΑΡΤΗΣΕΩΝ
Standards-Version: 3.9.6
Homepage: <ΙΣΤΟΣΕΛΙΔΑ UPSTREAM>
Vcs-Git: GIT
Vcs-Browser: ΣΥΝΔΕΣΜΟΣ GIT

nPackage: ΟΝΟΜΑ ΠΑΚΕΤΟΥ
Architecture: any
Depends: ${shlibs:Depends}, ${misc:Depends}
Description: <ΜΙΚΡΗ ΠΕΡΙΓΡΑΦΗ>
 <ΜΕΓΑΛΗ ΠΕΡΙΓΡΑΦΗ>```

> Σε αυτό το αρχείο, το **ΟΝΟΜΑ ΠΑΚΕΤΟΥ** είναι το όνομα του λογισμικού. Η **κατηγορία** είναι μία από [αυτές](http://packages.ubuntu.com/xenial/), αναλόγως σε ποια ταιριάζει περισσότερο το λογισμικό. Οι **σύνδεσμοι** που πρέπει να τοποθετηθούν στο αρχείο αναγράφονται στο αρχείο «**README**» του πηγαίου κώδικα. Η **προτεραιότητα** είναι συνήθως «**optional**», αλλά δεν θα επεκταθούμε σε αυτό, προς το παρόν. Μπορούμε να βρούμε τον **αρχικό συγγραφέα** του λογισμικού στο αρχείο «**AUTHORS**» του πηγαίου κώδικα. Η **λίστα των εξαρτήσεων** αναγράφεται στο αρχείο «**configure.ac**» του πηγαίου κώδικα. Οπότε, βάσει αυτών, επεξεργαζόμαστε το περιεχόμενο του αρχείου «**debian/control**».



Το αρχείο «**debian/source/format**» πρέπει να έχει συγκεκριμένο περιεχόμενο, αναλόγως αν το λογισμικό έχει φτιαχτεί αποκλειστικά για το Debian ή είναι κάποιο λογισμικό upstream γενικότερα. Επειδή η συντριπτική πλειοψηφία των λογισμικών εμπίπτουν στην δεύτερη περίπτωση, το περιεχόμενο του αρχείο πρέπει να είναι το εξής:
```bash
3.0 (quilt)```

> Η άλλη περίπτωση είναι να είναι «**native**», αποκλειστικά για το Debian. Περίπτωση σχετικά σπάνια, αλλά ούτως ή άλλως, δεν επηρεάζει ιδιαίτερα την διαδικασία του packaging.


Το αρχείο «**ΛΟΓΙΣΜΙΚΟ.docs**» θα έχει το εξής περιεχόμενο (που παραπέμπει σε αρχεία του πηγαίου κώδικα upstream):
```bash
AUTHORS
NEWS
README```

> Πρόκειται για διάφορες χρήσιμες πληροφορίες που περιέχουν αρχεία στον πηγαίο κώδικα, που αφορούν το λογισμικό. Αφού τροποποιήσουμε τα αρχεία κατάλληλα, τα αποθηκεύουμε. Αυτό είναι και το κλειδί στην δημιουργία πακέτου από το μηδέν, η σωστή δομή και το περιεχόμενο των αρχείων του καταλόγου «**debian**».

![](https://cerebrux.files.wordpress.com/2016/04/control1.png?w=840)
![](https://cerebrux.files.wordpress.com/2016/04/copyright.png?w=837)
![](https://cerebrux.files.wordpress.com/2016/04/docs.png?w=840) ![](https://cerebrux.files.wordpress.com/2016/04/watch.png?w=841)
![](https://cerebrux.files.wordpress.com/2016/04/fomat.png?w=841)


> **Παρατήτηση**: Σε αυτό το παράδειγμα, δεν χρειάστηκε να επεξεργαστούμε το αρχείο «debian/rules», περίπτωση που σχεδόν ποτέ δεν ισχύει. Στην δημιουργία ενός πακέτου, αυτό το αρχείο θα μας απασχολήσει ιδιαιτέρως. Όμως, δεν θα γίνει αναφορά στην λειτουργία του στο παρόν άρθρο.


## • Βήμα 6: Καταγραφή αλλαγών



Δεν πρέπει να ξεχάσουμε να ενημερώσουμε το αρχείο «**debian/changelog**», το οποίο είδαμε στην προηγούμενη ενότητα σχετικά με την αναβάθμιση των πακέτων. Πλέον, βρισκόμαστε στο σημείο όπου από εδώ και μπρος, τα βήματα που θα κάνουμε είναι ίδια με αυτά της προηγούμενης περίπτωσης.

Εκτελούμε:
```bash
cd .. && dch -r```

Προσθέτουμε ένα **tag** στην έκδοση, αλλάζουμε την κωδική ονομασία της διανομής σε αυτή που αντιστοιχεί στην έκδοση του Ubuntu για την οποία φτιάχνουμε το πακέτο, διότι θα έχει κάποια ονομασία από έκδοση του Debian και τέλος, αποθηκεύουμε το αρχείο ως «**changelog**».
![](https://cerebrux.files.wordpress.com/2016/04/dch1.png?w=735)
![](https://cerebrux.files.wordpress.com/2016/04/changelog1.png?w=735)
![](https://cerebrux.files.wordpress.com/2016/04/changelog2.png?w=735)


## • Βήμα 7: Δημιουργία πακέτου



Ξανά, συνεχίζουμε ακριβώς όπως και στην περίπτωση της αναβάθμισης. Βρισκόμαστε στον φάκελο του λογισμικού. Προκειμένου να χτίσουμε το πακέτο έτσι όπως το διαμορφώσαμε, απλά εκτελούμε στο τερματικό:
```bash
debuild -S```
Και το πρόγραμμα θα ξεκινήσει και θα ολοκληρώσει την διαδικασία. Αν δεν έχουμε παραλείψει κάτι και έγιναν όλα σωστά, μετά από μερικά δευτερόλεπτα θα δούμε αυτό:
```bash
Successfully signed dsc and change filesdebuild -S```
Ίσως μας ζητηθεί να πληκτρολογήσουμε και τον κωδικό του κλειδιού GPG που έχουμε δημιουργήσει προηγουμένως.

Αφού ολοκληρωθεί το χτίσιμο του πακέτου, πίσω στον αρχικό μας φάκελο (αυτόν που έχουμε δημιουργήσει για να δουλεύουμε) θα έχουν δημιουργηθεί τα εξής αρχεία:

* Tο tarball «**ΟΝΟΜΑ_ΠΑΚΕΤΟΥ_ΕΚΔΟΣΗ~tag.debian.tar**», το οποίο περιέχει την νεότερη έκδοση του λογισμικού, μαζί με τον κατάλογο «**debian**» ενημερωμένο, δηλαδή, με όλες τις αλλαγές που εφαρμόσαμε στα προηγούμενα βήματα.
* Η εικόνα «**ΟΝΟΜΑ_ΠΑΚΕΤΟΥ_ΕΚΔΟΣΗ~tag.dsc**», δηλαδή η εικόνα του νέου πακέτου για το Ubuntu από το παραπάνω tarball πάνω στην οποία θα γίνει έλεγχος.
* Το αρχείο «**ΟΝΟΜΑ_ΠΑΚΕΤΟΥ_ΕΚΔΟΣΗ~tag_source.build**».
* Το αρχείο «**ΟΝΟΜΑ_ΠΑΚΕΤΟΥ_ΕΚΔΟΣΗ~tag_source.changes**».

![](https://cerebrux.files.wordpress.com/2016/04/debuild1.png?w=735)
![](https://cerebrux.files.wordpress.com/2016/04/debuild2.png?w=735)


## • Βήμα 8: Έλεγχος πακέτου



Το πακέτο μας έχει δημιουργηθεί, όπως και στην περίπτωση της αναβάθμισης, απομένει ο έλεγχος.

Αφού επιστρέψουμε στον αρχικό μας φάκελο:
```bash
cd ..```

Eκτελούμε στο τερματικό:
```bash
sbuild --dist=xenial --arch=amd64 -A -c xenial-amd64 ΟΝΟΜΑ_ΠΑΚΕΤΟΥ_ΕΚΔΟΣΗ~tag.dsc```

> **Παρατήρηση**: Όπως και προηγουμένως, στην ενότητα για την κατάλληλη ρύθμιση του *sbuild* χρειάστηκε προσοχή στο όνομα που θα δώσουμε στο περιβάλλον ελέγχου καθώς και στον ορισμό της έκδοσης του Ubuntu για την οποία δημιουργούμε το πακέτο. Βλέπουμε πως η ονομασία του περιβάλλοντος και η κωδική ονομασία της έκδοσης χρησιμοποιούνται στην παραπάνω εντολή. Αναλόγως, λοιπόν, τις ονομασίες που ορίσαμε τότε και την διανομή για την οποία πακετάρουμε το λογισμικό, κάνουμε τις κατάλληλες αλλαγές στην εντολή παραπάνω.
> 
**Επεξήγηση**: Η διαδικασία που εφαρμόζεται με την εκτέλεση της παραπάνω εντολής, δεν είναι άλλη από την δημιουργία και την ενημέρωση ενός συστήματος Ubuntu (αυτή άλλωστε είναι η δουλειά του *sbuild*), στην default κατάστασή του, προκειμένου να εκτελεστεί εκεί η προσπάθεια εγκατάστασης του πακέτου που δημιουργήσαμε και να γίνει ένας εκτεταμένος έλεγχος για την σωστή πρόοδο της διαδικασίας. Η διαδικασία αυτή θα αργήσει, σχετικά, να ολοκληρωθεί. Οπότε, περιμένουμε.

Αφού ολοκληρωθεί η διαδικασία, στο τέλος θα δούμε μία περίληψη (**Summary**) του ελέγχου που πραγματοποιήθηκε με την εκτέλεση της τελευταίας εντολής. Στο summary, λοιπόν, θα υπάρχει η γραμμή όπου θα αναγράφεται το αποτέλεσμα του ελέγχου (**Status**), το οποίο θα είναι είτε «**Successful**» εφόσον ο έλεγχος ολοκληρώθηκε επιτυχώς, είτε «**Failed**» αν υπήρξαν σφάλματα.

Αν ο έλεγχος ολοκληρωθεί με επιτυχία, στον αρχικό μας φάκελο θα έχουμε επιπλέον τα εξής αρχεία:

* **ΟΝΟΜΑ_ΠΑΚΕΤΟΥ_ΕΚΔΟΣΗ~tag_amd64.build**
* **ΟΝΟΜΑ_ΠΑΚΕΤΟΥ_ΕΚΔΟΣΗ~tag_amd64.changes**
* **ΟΝΟΜΑ_ΠΑΚΕΤΟΥ_ΕΚΔΟΣΗ~tag_amd64.deb**
* **ΟΝΟΜΑ_ΠΑΚΕΤΟΥ-dbgsym_ΕΚΔΟΣΗ~tag_amd64.ddeb**
 
![](https://cerebrux.files.wordpress.com/2016/04/sbuild1.png?w=735)
![](https://cerebrux.files.wordpress.com/2016/04/sbuild2.png?w=735)
![](https://cerebrux.files.wordpress.com/2016/04/sbuild3.png?w=735)
 
Και σε αυτή την περίπτωση, το πείραμα φαίνεται να ολοκληρώθηκε επιτυχώς. Ας κάνουμε μία επαλήθευση.

![](https://cerebrux.files.wordpress.com/2016/04/run1.png?w=680)


